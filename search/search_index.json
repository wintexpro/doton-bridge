{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83c\udf09 Overview \u00b6 Getting started \u00b6 If you looking for a simple way to try bridge in action, please visit the page - Running Locally Summary \u00b6 DOTON \u00b6 DOTON is a message passing protocol based on ChainBridge protocol and extended in order to make it possible to work with TON chain. Currently, we support message passing between TON and Substrate-based chains. ChainBridge \u00b6 At a high level, ChainBridge is a message passing protocol. Events on a source chain are used to create a message that is then delivered to the destination chain. We define the concept of a Listener to extract events from a chain and construct a message, and a Writer to interpret messages and submit transactions to a chain. Relevant repos \u00b6 ChainSafe/ChainBridge \u00b6 This is the original repository of the core bridging software that Relayers run between chains. wintexpro/DOTON \u00b6 This is a fork of the original repository to which the functionality of interacting with the TON node and some additional business logic were added. wintexpro/doton-substrate \u00b6 A substrate pallet that can be integrated into a chain, as well as an example pallet to demonstrate passing simple message between TON and Substrate chains. wintexpro/doton-substrate-chain \u00b6 A simple substrate chain for testing and demo purposes. wintexpro/chainbridge-utils \u00b6 A collection of packages used by the core bridging software. This repository is a fork from ChainSafe/chainbridge-utils to which the TON specifically functions were added.","title":"Overview"},{"location":"#overview","text":"","title":"\ud83c\udf09  Overview "},{"location":"#getting-started","text":"If you looking for a simple way to try bridge in action, please visit the page - Running Locally","title":"Getting started"},{"location":"#summary","text":"","title":"Summary"},{"location":"#doton","text":"DOTON is a message passing protocol based on ChainBridge protocol and extended in order to make it possible to work with TON chain. Currently, we support message passing between TON and Substrate-based chains.","title":"DOTON"},{"location":"#chainbridge","text":"At a high level, ChainBridge is a message passing protocol. Events on a source chain are used to create a message that is then delivered to the destination chain. We define the concept of a Listener to extract events from a chain and construct a message, and a Writer to interpret messages and submit transactions to a chain.","title":"ChainBridge"},{"location":"#relevant-repos","text":"","title":"Relevant repos"},{"location":"#chainsafechainbridge","text":"This is the original repository of the core bridging software that Relayers run between chains.","title":"ChainSafe/ChainBridge"},{"location":"#wintexprodoton","text":"This is a fork of the original repository to which the functionality of interacting with the TON node and some additional business logic were added.","title":"wintexpro/DOTON"},{"location":"#wintexprodoton-substrate","text":"A substrate pallet that can be integrated into a chain, as well as an example pallet to demonstrate passing simple message between TON and Substrate chains.","title":"wintexpro/doton-substrate"},{"location":"#wintexprodoton-substrate-chain","text":"A simple substrate chain for testing and demo purposes.","title":"wintexpro/doton-substrate-chain"},{"location":"#wintexprochainbridge-utils","text":"A collection of packages used by the core bridging software. This repository is a fork from ChainSafe/chainbridge-utils to which the TON specifically functions were added.","title":"wintexpro/chainbridge-utils"},{"location":"cli-options/","text":"CLI Options \u00b6 Flags \u00b6 Global \u00b6 -- config value JSON configuration file -- verbosity value Supports levels crit ( silent ) to trce ( trace ) ( default : \"info\" ) -- keystore value Path to keystore directory ( default : \"./keys\" ) -- blockstore value Specify path for blockstore -- fresh Disables loading from blockstore at start . Opts will still be used if specified . ( default : false ) -- latest Overrides blockstore and start block , starts from latest block ( default : false ) -- metrics Enables metric server ( default : false ) -- metricsPort value Port to serve metrics on ( default : 8001 ) -- testkey value Applies a predetermined test keystore to the chains . -- help , - h show help ( default : false ) -- version , - v print the version ( default : false ) Deploy Management \u00b6 doton contracts send-grams \u00b6 send grams from the giver to the contracts doton contracts deploy \u00b6 deploy the set of ton contracts doton contracts deploy-relayer \u00b6 deploy the relayer ton contract --from Address of relayer doton contracts deploy-wallet \u00b6 deploy the wallet contract doton contracts get-balance \u00b6 get of the wallet balance doton contracts setup \u00b6 setup contracts of brige doton contracts send-tokens \u00b6 transfer the balance from owner's account to another account --amount Amount of tokens --to Recipient --nonce Nonce Account Management \u00b6 The commands can be used to manage keys in the local keystore. You can view available keys with doton accounts list . doton accounts generate \u00b6 -- password value Password used to encrypt the keystore . Used with -- generate , -- import , or -- unlock -- sr25519 Specify account / key type as sr25519 . ( default : false ) -- secp256k1 Specify account / key type as secp256k1 . ( default : false ) -- ed25519 Specify account / key type as ed25519 . ( default : false ) -- network value Specify the network to use for the address encoding ( substrate / polkadot / centrifuge ) ( default : substrate ) doton accounts import \u00b6 -- seedphrase value Derive keys from a seed phrase and import them into a keystore . -- ton Import an existing ton keystore . ( default : false ) -- privateKey value Import a hex representation of a private key into a keystore . -- sr25519 Specify account / key type as sr25519 . ( default : false ) -- secp256k1 Specify account / key type as secp256k1 . ( default : false ) -- password value Password used to encrypt the keystore . Used with -- generate , -- import , or -- unlock -- network value Specify the network to use for the address encoding ( substrate / polkadot / centrifuge ) ( default : substrate ) Environment Variables \u00b6 KEYSTORE_PASSWORD : The password to use when loading the keystore. BLOCK_TIMEOUT : The duration (seconds) until a chain is considered \"unhealthy\"","title":"CLI Options"},{"location":"cli-options/#cli-options","text":"","title":"CLI Options"},{"location":"cli-options/#flags","text":"","title":"Flags"},{"location":"cli-options/#global","text":"-- config value JSON configuration file -- verbosity value Supports levels crit ( silent ) to trce ( trace ) ( default : \"info\" ) -- keystore value Path to keystore directory ( default : \"./keys\" ) -- blockstore value Specify path for blockstore -- fresh Disables loading from blockstore at start . Opts will still be used if specified . ( default : false ) -- latest Overrides blockstore and start block , starts from latest block ( default : false ) -- metrics Enables metric server ( default : false ) -- metricsPort value Port to serve metrics on ( default : 8001 ) -- testkey value Applies a predetermined test keystore to the chains . -- help , - h show help ( default : false ) -- version , - v print the version ( default : false )","title":"Global"},{"location":"cli-options/#deploy-management","text":"","title":"Deploy Management"},{"location":"cli-options/#doton-contracts-send-grams","text":"send grams from the giver to the contracts","title":"doton contracts send-grams"},{"location":"cli-options/#doton-contracts-deploy","text":"deploy the set of ton contracts","title":"doton contracts deploy"},{"location":"cli-options/#doton-contracts-deploy-relayer","text":"deploy the relayer ton contract --from Address of relayer","title":"doton contracts deploy-relayer"},{"location":"cli-options/#doton-contracts-deploy-wallet","text":"deploy the wallet contract","title":"doton contracts deploy-wallet"},{"location":"cli-options/#doton-contracts-get-balance","text":"get of the wallet balance","title":"doton contracts get-balance"},{"location":"cli-options/#doton-contracts-setup","text":"setup contracts of brige","title":"doton contracts setup"},{"location":"cli-options/#doton-contracts-send-tokens","text":"transfer the balance from owner's account to another account --amount Amount of tokens --to Recipient --nonce Nonce","title":"doton contracts send-tokens"},{"location":"cli-options/#account-management","text":"The commands can be used to manage keys in the local keystore. You can view available keys with doton accounts list .","title":"Account Management"},{"location":"cli-options/#doton-accounts-generate","text":"-- password value Password used to encrypt the keystore . Used with -- generate , -- import , or -- unlock -- sr25519 Specify account / key type as sr25519 . ( default : false ) -- secp256k1 Specify account / key type as secp256k1 . ( default : false ) -- ed25519 Specify account / key type as ed25519 . ( default : false ) -- network value Specify the network to use for the address encoding ( substrate / polkadot / centrifuge ) ( default : substrate )","title":"doton accounts generate"},{"location":"cli-options/#doton-accounts-import","text":"-- seedphrase value Derive keys from a seed phrase and import them into a keystore . -- ton Import an existing ton keystore . ( default : false ) -- privateKey value Import a hex representation of a private key into a keystore . -- sr25519 Specify account / key type as sr25519 . ( default : false ) -- secp256k1 Specify account / key type as secp256k1 . ( default : false ) -- password value Password used to encrypt the keystore . Used with -- generate , -- import , or -- unlock -- network value Specify the network to use for the address encoding ( substrate / polkadot / centrifuge ) ( default : substrate )","title":"doton accounts import"},{"location":"cli-options/#environment-variables","text":"KEYSTORE_PASSWORD : The password to use when loading the keystore. BLOCK_TIMEOUT : The duration (seconds) until a chain is considered \"unhealthy\"","title":"Environment Variables"},{"location":"configuration/","text":"Configuration \u00b6 A chain configurations take this form: { \"name\": \"freeTON\", // Human-readable name \"type\": \"ton\", // Chain type (eg. \"ton\" or \"substrate\") \"id\": \"0\", // Chain ID \"endpoint\": \"ws://<host>:<port>\", // Node endpoint \"from\": \"0:164d61e...\", // On-chain address of relayer \"opts\": {}, // Chain-specific configuration options (see below) } See config.json.example for an example configuration. Ton Options \u00b6 Ton chains support the following additional options: { \"contractsPath\": \"/contracts\", // The path to contract files (ABI, TVC) \"receiver\": \"0:e50f...92ee\", // The contract Reciver address (Deploy script in /scripts/Makefile target: ton-deploy-contracts) \"startBlock\": \"1\", // The block to start processing events from (default: 0) \"workchainID\": \"0\" // The workchain from which the events will be processing } Substrate Options \u00b6 Substrate supports the following additonal options: { \" startBlock \" : \" 1234 \" // The block to start processing events from ( default : 0 ) \" useExtendedCall \" : \" true \" // Extend extrinsic calls to substrate with ResourceID . Used for backward compatibility with example pallet . } Blockstore \u00b6 The blockstore is used to record the last block the relayer processed, so it can pick up where it left off. If a startBlock option is provided (see Configuration ), then the greater of startBlock and the latest block in the blockstore is used at startup. To disable loading from the blockstore specify the --fresh flag. A custom path for the blockstore can be provided with --blockstore <path> . For development, the --latest flag can be used to start from the current block and override any other configuration. Keystore \u00b6 DOTON requires keys to sign and submit transactions, and to identify each bridge node on chain. To use secure keys, see doton accounts --help . The keystore password can be supplied with the KEYSTORE_PASSWORD environment variable. To import external ton keys, such as those generated with tonos-cli, use doton accounts import --ton /path/to/key.json or doton accounts import --ton --seedphrase \"action glow era all liquid critic achieve lawsuit era anger loud slight\" To import private keys as keystores, use doton account import --privateKey key . For testing purposes, doton provides 5 test keys. The can be used with --testkey <name> , where name is one of Alice , Bob , Charlie , Dave , or Eve .","title":"Overview"},{"location":"configuration/#configuration","text":"A chain configurations take this form: { \"name\": \"freeTON\", // Human-readable name \"type\": \"ton\", // Chain type (eg. \"ton\" or \"substrate\") \"id\": \"0\", // Chain ID \"endpoint\": \"ws://<host>:<port>\", // Node endpoint \"from\": \"0:164d61e...\", // On-chain address of relayer \"opts\": {}, // Chain-specific configuration options (see below) } See config.json.example for an example configuration.","title":"Configuration"},{"location":"configuration/#ton-options","text":"Ton chains support the following additional options: { \"contractsPath\": \"/contracts\", // The path to contract files (ABI, TVC) \"receiver\": \"0:e50f...92ee\", // The contract Reciver address (Deploy script in /scripts/Makefile target: ton-deploy-contracts) \"startBlock\": \"1\", // The block to start processing events from (default: 0) \"workchainID\": \"0\" // The workchain from which the events will be processing }","title":"Ton Options"},{"location":"configuration/#substrate-options","text":"Substrate supports the following additonal options: { \" startBlock \" : \" 1234 \" // The block to start processing events from ( default : 0 ) \" useExtendedCall \" : \" true \" // Extend extrinsic calls to substrate with ResourceID . Used for backward compatibility with example pallet . }","title":"Substrate Options"},{"location":"configuration/#blockstore","text":"The blockstore is used to record the last block the relayer processed, so it can pick up where it left off. If a startBlock option is provided (see Configuration ), then the greater of startBlock and the latest block in the blockstore is used at startup. To disable loading from the blockstore specify the --fresh flag. A custom path for the blockstore can be provided with --blockstore <path> . For development, the --latest flag can be used to start from the current block and override any other configuration.","title":"Blockstore"},{"location":"configuration/#keystore","text":"DOTON requires keys to sign and submit transactions, and to identify each bridge node on chain. To use secure keys, see doton accounts --help . The keystore password can be supplied with the KEYSTORE_PASSWORD environment variable. To import external ton keys, such as those generated with tonos-cli, use doton accounts import --ton /path/to/key.json or doton accounts import --ton --seedphrase \"action glow era all liquid critic achieve lawsuit era anger loud slight\" To import private keys as keystores, use doton account import --privateKey key . For testing purposes, doton provides 5 test keys. The can be used with --testkey <name> , where name is one of Alice , Bob , Charlie , Dave , or Eve .","title":"Keystore"},{"location":"installation/","text":"Installation \u00b6 Relay Node \u00b6 Dependencies \u00b6 go 1.15 Subkey : Used for substrate key management. Only required if connecting to a substrate chain. TON-SDK : export CGO_LDFLAGS=\"-L/.../TON-SDK/target/release/deps/ -lton_client\" Building from Source \u00b6 To build doton in ./build . $ make build or Use go install to add doton to your GOBIN. $ make install Substrate Doton Node \u00b6 Dependencies \u00b6 Rust Developer Environment Rust Nightly Toolchain $ rustup install nightly-2020-10-01 $ rustup default nightly-2020-10-01 $ rustup target add wasm32-unknown-unknown --toolchain nightly-2020-10-01 Building from Source \u00b6 $ git clone https://github.com/wintexpro/doton-substrate-chain.git $ cargo build --release","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#relay-node","text":"","title":"Relay Node"},{"location":"installation/#dependencies","text":"go 1.15 Subkey : Used for substrate key management. Only required if connecting to a substrate chain. TON-SDK : export CGO_LDFLAGS=\"-L/.../TON-SDK/target/release/deps/ -lton_client\"","title":"Dependencies"},{"location":"installation/#building-from-source","text":"To build doton in ./build . $ make build or Use go install to add doton to your GOBIN. $ make install","title":"Building from Source"},{"location":"installation/#substrate-doton-node","text":"","title":"Substrate Doton Node"},{"location":"installation/#dependencies_1","text":"Rust Developer Environment Rust Nightly Toolchain $ rustup install nightly-2020-10-01 $ rustup default nightly-2020-10-01 $ rustup target add wasm32-unknown-unknown --toolchain nightly-2020-10-01","title":"Dependencies"},{"location":"installation/#building-from-source_1","text":"$ git clone https://github.com/wintexpro/doton-substrate-chain.git $ cargo build --release","title":"Building from Source"},{"location":"local/","text":"doton-local-network \u00b6 A docker development environment for a doton local network Requirements \u00b6 docker docker-compose Launching bridge components \u00b6 If you got some old versions of doton components, make sure that you got latest docker images on your local environment. You can just check your latest tagged images digests with digests on dockerhub . Or just remove all local images, because this guide's commands would download them if not find. Clone this repo: $ git clone git@github.com:wintexpro/doton-local-network.git Inside ./doton-local-network directory run: $ make run-chains After making sure TON OS SE and substrate services are running, you should run setup script $ make run-setup That executes to send initial value to contracts and deploy them to local TON node, also set up a substrate node for interacting with DOTON protocol. After setup, this command attaches you to a docker container with tonos-cli and halva-cli tools. Make sure that containers which were launched during previous commands (doton-setup-bridge and doton-setup) stopped their work. You need to run the relay nodes by running the command (please, make sure the setup scripts were done): $ make run-alice After making sure alice node is running, you must deploy another 2 relayers At last, you can run $ CONFIG_NAME = config2.json make deploy-relayer $ CONFIG_NAME = config3.json make deploy-relayer And run they $ make run-bob $ make run-charlie Run local polkadot UI \u00b6 If you need to run local polkadotjs UI, you can run command: $ docker run --rm -it --name polkadot-ui --network doton-local-network_default --link doton-sub-chain -p 8001 :80 jacogr/polkadot-js-apps:0.79.1 Setting up Polkadot JS Apps \u00b6 You can interact with a substrate local node by visiting https://polkadot.js.org/apps/ and choose \"Local Node\" network You will need to add these definitions to the developer settings : { \"Message\" : \"Text\" , \"chainbridge::ChainId\" : \"u8\" , \"ExtAddress\" : \"Text\" , \"ChainId\" : \"u8\" , \"ResourceId\" : \"[u8; 32]\" , \"Nonce\" : \"u64\" , \"DepositNonce\" : \"u64\" , \"ProposalVotes\" : { \"votes_for\" : \"Vec<AccountId>\" , \"votes_against\" : \"Vec<AccountId>\" , \"status\" : \"enum\" }, \"Erc721Token\" : { \"id\" : \"TokenId\" , \"metadata\" : \"Vec<u8>\" }, \"TokenId\" : \"U256\" , \"Address\" : \"AccountId\" , \"LookupSource\" : \"AccountId\" , \"VrfResult\" : { \"pk\" : \"Vec<u8>\" , \"val\" : \"Vec<u8>\" , \"proof\" : \"Vec<u8>\" } } Setting substrate initial balance \u00b6 For working example you should set some balance for account on substrate network. To do this you should perform some steps: 1. Open an https://polkadot.js.org/apps/ 2. Make sure that local node was choosen 3. On https://polkadot.js.org/apps/ choose Accounts->Accounts->Add account. We reccomend you to create new account, because of existing accounts has got large amount of balance 4. Go throught Developers->sudo 5. On 'Sudo access' tab choose balances extrinsic with setBalance command 6. Choose created account for who option (Or choose any if you want or didn't create new) 7. Set new_free option with some amount (ex 10000) and click submit sudo. Substrate-TON transfer \u00b6 On https://polkadot.js.org/apps/ choose developers->extrinsic Set an example value for submit the following extrinsic option with transferNative function (to the right) Set some amount . That value will be transfered to TON network recipient field should be filled with TON recipient address. You can obtain it by launching this command from repository (doton-local-network) root $ make get-balance Set dest_id to 2 (chain id of TON network in configs/config.json ) Click Submit transaction Unlock with password 123456 and click Sign and Submit Wait for a while and check TON recipient balance with command from 4 . It should be equal with sended amount. TON-Substrate transfer \u00b6 | Current version doesn't supports any user interface, excepts cli, so this steps can be complicated For sending tokens to the substrate network you should use this command from repository root: AMOUNT =< amount > TO =< substrate address > NONCE =< nonce > make ton - send - tokens Parameters: \\<amount> - amount of tokens that will be sent \\<substrate address> - adress of substrate recepient \\<nonce> IMPORTANT! you should increment nonce by yourself. Start with 1 . Example: $ AMOUNT = 10 TO = 5CaNkosmQfEaLnYjdegNH5KSPAtPeMtkjkM4xAeQMv1gUGCp NONCE = 1 make ton-send-tokens Considering ton local node can't produce blocks without a messages, you should run several times previous command with --amount 0 and incremented nonce (one by one, start from previous + 1) Example: $ AMOUNT = 0 TO = 5CaNkosmQfEaLnYjdegNH5KSPAtPeMtkjkM4xAeQMv1gUGCp NONCE = 2 make ton-send-tokens $ AMOUNT = 0 TO = 5CaNkosmQfEaLnYjdegNH5KSPAtPeMtkjkM4xAeQMv1gUGCp NONCE = 3 make ton-send-tokens Wait for a while and check Accounts tab on https://polkadot.js.org/apps/. Balance is expected to increase.","title":"Running Locally"},{"location":"local/#doton-local-network","text":"A docker development environment for a doton local network","title":"doton-local-network"},{"location":"local/#requirements","text":"docker docker-compose","title":"Requirements"},{"location":"local/#launching-bridge-components","text":"If you got some old versions of doton components, make sure that you got latest docker images on your local environment. You can just check your latest tagged images digests with digests on dockerhub . Or just remove all local images, because this guide's commands would download them if not find. Clone this repo: $ git clone git@github.com:wintexpro/doton-local-network.git Inside ./doton-local-network directory run: $ make run-chains After making sure TON OS SE and substrate services are running, you should run setup script $ make run-setup That executes to send initial value to contracts and deploy them to local TON node, also set up a substrate node for interacting with DOTON protocol. After setup, this command attaches you to a docker container with tonos-cli and halva-cli tools. Make sure that containers which were launched during previous commands (doton-setup-bridge and doton-setup) stopped their work. You need to run the relay nodes by running the command (please, make sure the setup scripts were done): $ make run-alice After making sure alice node is running, you must deploy another 2 relayers At last, you can run $ CONFIG_NAME = config2.json make deploy-relayer $ CONFIG_NAME = config3.json make deploy-relayer And run they $ make run-bob $ make run-charlie","title":"Launching bridge components"},{"location":"local/#run-local-polkadot-ui","text":"If you need to run local polkadotjs UI, you can run command: $ docker run --rm -it --name polkadot-ui --network doton-local-network_default --link doton-sub-chain -p 8001 :80 jacogr/polkadot-js-apps:0.79.1","title":"Run local polkadot UI"},{"location":"local/#setting-up-polkadot-js-apps","text":"You can interact with a substrate local node by visiting https://polkadot.js.org/apps/ and choose \"Local Node\" network You will need to add these definitions to the developer settings : { \"Message\" : \"Text\" , \"chainbridge::ChainId\" : \"u8\" , \"ExtAddress\" : \"Text\" , \"ChainId\" : \"u8\" , \"ResourceId\" : \"[u8; 32]\" , \"Nonce\" : \"u64\" , \"DepositNonce\" : \"u64\" , \"ProposalVotes\" : { \"votes_for\" : \"Vec<AccountId>\" , \"votes_against\" : \"Vec<AccountId>\" , \"status\" : \"enum\" }, \"Erc721Token\" : { \"id\" : \"TokenId\" , \"metadata\" : \"Vec<u8>\" }, \"TokenId\" : \"U256\" , \"Address\" : \"AccountId\" , \"LookupSource\" : \"AccountId\" , \"VrfResult\" : { \"pk\" : \"Vec<u8>\" , \"val\" : \"Vec<u8>\" , \"proof\" : \"Vec<u8>\" } }","title":"Setting up Polkadot JS Apps"},{"location":"local/#setting-substrate-initial-balance","text":"For working example you should set some balance for account on substrate network. To do this you should perform some steps: 1. Open an https://polkadot.js.org/apps/ 2. Make sure that local node was choosen 3. On https://polkadot.js.org/apps/ choose Accounts->Accounts->Add account. We reccomend you to create new account, because of existing accounts has got large amount of balance 4. Go throught Developers->sudo 5. On 'Sudo access' tab choose balances extrinsic with setBalance command 6. Choose created account for who option (Or choose any if you want or didn't create new) 7. Set new_free option with some amount (ex 10000) and click submit sudo.","title":"Setting substrate initial balance"},{"location":"local/#substrate-ton-transfer","text":"On https://polkadot.js.org/apps/ choose developers->extrinsic Set an example value for submit the following extrinsic option with transferNative function (to the right) Set some amount . That value will be transfered to TON network recipient field should be filled with TON recipient address. You can obtain it by launching this command from repository (doton-local-network) root $ make get-balance Set dest_id to 2 (chain id of TON network in configs/config.json ) Click Submit transaction Unlock with password 123456 and click Sign and Submit Wait for a while and check TON recipient balance with command from 4 . It should be equal with sended amount.","title":"Substrate-TON transfer"},{"location":"local/#ton-substrate-transfer","text":"| Current version doesn't supports any user interface, excepts cli, so this steps can be complicated For sending tokens to the substrate network you should use this command from repository root: AMOUNT =< amount > TO =< substrate address > NONCE =< nonce > make ton - send - tokens Parameters: \\<amount> - amount of tokens that will be sent \\<substrate address> - adress of substrate recepient \\<nonce> IMPORTANT! you should increment nonce by yourself. Start with 1 . Example: $ AMOUNT = 10 TO = 5CaNkosmQfEaLnYjdegNH5KSPAtPeMtkjkM4xAeQMv1gUGCp NONCE = 1 make ton-send-tokens Considering ton local node can't produce blocks without a messages, you should run several times previous command with --amount 0 and incremented nonce (one by one, start from previous + 1) Example: $ AMOUNT = 0 TO = 5CaNkosmQfEaLnYjdegNH5KSPAtPeMtkjkM4xAeQMv1gUGCp NONCE = 2 make ton-send-tokens $ AMOUNT = 0 TO = 5CaNkosmQfEaLnYjdegNH5KSPAtPeMtkjkM4xAeQMv1gUGCp NONCE = 3 make ton-send-tokens Wait for a while and check Accounts tab on https://polkadot.js.org/apps/. Balance is expected to increase.","title":"TON-Substrate transfer"},{"location":"metrics/","text":"Metrics \u00b6 Basic metrics and a health status check can be enabled with the --metrics flag (default port 8001 , use --metricsPort to specify). Prometheus \u00b6 Prometheus metrics are served on /metrics . For each chain that exists, this provides: - <chain>_blocks_processed : the number of blocks processed by the chains listener. - <chain>_latest_processed_block : most recent block that has been processed by the listener. - <chain>_latest_known_block : most recent block that exists on the chain. - <chain>_votes_submitted : number of votes submitted by the relayer. Health Check \u00b6 The endpoint /health will return the current known block height, and a timestamp of when it was first seen for every chain: ```json { \"chains\": [ { \"chainId\": \"Number\", \"height\": \"Number\", \"lastUpdated\": \"Date\" } ] } If the timestamp is at least 120 seconds old an error will be returned instead : ``` json { \" error \" : \" String \" }","title":"Metrics"},{"location":"metrics/#metrics","text":"Basic metrics and a health status check can be enabled with the --metrics flag (default port 8001 , use --metricsPort to specify).","title":"Metrics"},{"location":"metrics/#prometheus","text":"Prometheus metrics are served on /metrics . For each chain that exists, this provides: - <chain>_blocks_processed : the number of blocks processed by the chains listener. - <chain>_latest_processed_block : most recent block that has been processed by the listener. - <chain>_latest_known_block : most recent block that exists on the chain. - <chain>_votes_submitted : number of votes submitted by the relayer.","title":"Prometheus"},{"location":"metrics/#health-check","text":"The endpoint /health will return the current known block height, and a timestamp of when it was first seen for every chain: ```json { \"chains\": [ { \"chainId\": \"Number\", \"height\": \"Number\", \"lastUpdated\": \"Date\" } ] } If the timestamp is at least 120 seconds old an error will be returned instead : ``` json { \" error \" : \" String \" }","title":"Health Check"},{"location":"spec/","text":"ChainBridge Specification \u00b6 Summary \u00b6 ChainBridge is a modular multi-directional blockchain bridge to allow data and value transfer between any number of blockchains. This should enable users to specify a destination blockchain from their source chain, and send data to that blockchain for consumption on the destination chain. This could be a token that is locked on ChainA and redeemed on ChainB, or an operation that is executed on a destination chain and initiated on the source chain. The bridge should maintain a set of relayers that are authorized to make & process transfers across the different blockchains. The bridge design should be modular enough that the addition of a new type of transfer should not require a full re-deployment of the suite of tools, rather small modular upgrades. Definitions \u00b6 Chain ID \u00b6 Each chain has a unique 8-bit identifier. We presently define the following chain IDs (subject to change) Deposit Nonce \u00b6 A nonce must be generated for every transfer to ensure uniqueness. All implementations must track a sequential nonce (unsigned 64-bit integer) for each possible destination chain. This is included as a standard parameter for each transfer. Order is not enforced. Resource ID \u00b6 In order to provide generality, we need some way to associate some action on a source chain to some action on a destination chain. This may express tokenX on chain A is equivalent to tokenY on chain B, or to simply associate that some action performed on chain A should result in some other action occurring on chain B. All resource IDs are considered to have a Home Chain. The only strict requirements for Resource IDs is that they must be 32 bytes in length and the least significant byte must contain a chain ID. Transfer Flow \u00b6 User initiates a transfer on the source chain. Relayers observing the chain parse the parameters of the transfer and format them into a message. The message is parsed and then proposed on the destination chain. If the vote threshold is met, the proposal will be executed to finalize the transfer. After the initiation, a user should not be required to make any additional interactions. Transfer Types \u00b6 In a effort to balance the goals of allowing simple integration and proving generalized transfers, multiple transfer types are defined. Some or all of these may implemented for a chain. Event Description SimpleMessageTransfer Transfer of simple text message FungibleTransfer Transfer of fungible assets NonFungibleTransfer Transfer of non-fungible assets GenericTransfer Transfer of arbitrary data All transfers contain a source chain, destination chain, deposit nonce, resource ID and transfer-specific parameters. To date DOTON support only SimpleMessage transfer type SimpleMessage \u00b6 Field Type Description From variable sized bytes External address from an original chain Message variable sized bytes The string converted into a byte array Fungible \u00b6 Field Type Description Amount 256 bit uint The total number of assets being transferred Recipient 32 bytes The recipient address on the destination chain Non-Fungible \u00b6 Field Type Description Token ID 256 bit uint The unique identifier for the NFT Recipient 32 bytes The recipient address on the destination chain Metadata variable sized bytes Any additional data associated to the NFT Generic \u00b6 Field Type Description Metadata variable sized bytes An opaque payload to transmit Note: Addresses are limited to 32bytes in size, but may be smaller. They must always be compatible with the destination chain. Relayer Set \u00b6 Each chain implementation must track a set of relayers, and allow updating of the set as necessary. A threshold should also be maintained to define how many relayers must vote for a proposed transfer before is can be executed. For this initial implementation, the relayer set may be controlled by a single party. Multi-signature wallets can be used to distribute risk, if available on the chain. Implementation \u00b6 This sections defines the specifics of the ChainBridge implementation and the requirements for a chain integration. Components \u00b6 Chain \u00b6 A chain is loosely defined as consisting of three major components: Connection : A container for on chain interactions. Shared by the listener and writer. Listener : Observes chain state transitions to watch for initiated transfers. When a transfer is encountered it should construct a message and pass it to the router. Writer : Responsible for performing on-chain actions. This will parse a proposed transfer from a message and enact it on-chain. These vary considerably depending on the chain. As long as the on-chain components are compatible, following the internal message protocol should be sufficient to be compatible with the system. These components are intended for architectural guidance and are only loosely constrained. Message \u00b6 A message represents a single transfer and its associated parameters. type Message struct { Source ChainId Destination ChainId Type TransferType DepositNonce Nonce ResourceId ResourceId Payload [] interface {} } The payload field contains the data for the specific transfer, as defined above . Router \u00b6 The router is responsible for taking messages from a source chain and routing them to their destination chain. The router provides an interface to allow Listeners to submit constructed messages: type Router interface { Send ( message msg . Message ) error } All chains must fulfill a Writer interface to receive messages from the router: type Writer interface { ResolveMessage ( message msg . Message ) bool }","title":"ChainBridge"},{"location":"spec/#chainbridge-specification","text":"","title":"ChainBridge Specification"},{"location":"spec/#summary","text":"ChainBridge is a modular multi-directional blockchain bridge to allow data and value transfer between any number of blockchains. This should enable users to specify a destination blockchain from their source chain, and send data to that blockchain for consumption on the destination chain. This could be a token that is locked on ChainA and redeemed on ChainB, or an operation that is executed on a destination chain and initiated on the source chain. The bridge should maintain a set of relayers that are authorized to make & process transfers across the different blockchains. The bridge design should be modular enough that the addition of a new type of transfer should not require a full re-deployment of the suite of tools, rather small modular upgrades.","title":"Summary"},{"location":"spec/#definitions","text":"","title":"Definitions"},{"location":"spec/#chain-id","text":"Each chain has a unique 8-bit identifier. We presently define the following chain IDs (subject to change)","title":"Chain ID"},{"location":"spec/#deposit-nonce","text":"A nonce must be generated for every transfer to ensure uniqueness. All implementations must track a sequential nonce (unsigned 64-bit integer) for each possible destination chain. This is included as a standard parameter for each transfer. Order is not enforced.","title":"Deposit Nonce"},{"location":"spec/#resource-id","text":"In order to provide generality, we need some way to associate some action on a source chain to some action on a destination chain. This may express tokenX on chain A is equivalent to tokenY on chain B, or to simply associate that some action performed on chain A should result in some other action occurring on chain B. All resource IDs are considered to have a Home Chain. The only strict requirements for Resource IDs is that they must be 32 bytes in length and the least significant byte must contain a chain ID.","title":"Resource ID"},{"location":"spec/#transfer-flow","text":"User initiates a transfer on the source chain. Relayers observing the chain parse the parameters of the transfer and format them into a message. The message is parsed and then proposed on the destination chain. If the vote threshold is met, the proposal will be executed to finalize the transfer. After the initiation, a user should not be required to make any additional interactions.","title":"Transfer Flow"},{"location":"spec/#transfer-types","text":"In a effort to balance the goals of allowing simple integration and proving generalized transfers, multiple transfer types are defined. Some or all of these may implemented for a chain. Event Description SimpleMessageTransfer Transfer of simple text message FungibleTransfer Transfer of fungible assets NonFungibleTransfer Transfer of non-fungible assets GenericTransfer Transfer of arbitrary data All transfers contain a source chain, destination chain, deposit nonce, resource ID and transfer-specific parameters. To date DOTON support only SimpleMessage transfer type","title":"Transfer Types"},{"location":"spec/#simplemessage","text":"Field Type Description From variable sized bytes External address from an original chain Message variable sized bytes The string converted into a byte array","title":"SimpleMessage"},{"location":"spec/#fungible","text":"Field Type Description Amount 256 bit uint The total number of assets being transferred Recipient 32 bytes The recipient address on the destination chain","title":"Fungible"},{"location":"spec/#non-fungible","text":"Field Type Description Token ID 256 bit uint The unique identifier for the NFT Recipient 32 bytes The recipient address on the destination chain Metadata variable sized bytes Any additional data associated to the NFT","title":"Non-Fungible"},{"location":"spec/#generic","text":"Field Type Description Metadata variable sized bytes An opaque payload to transmit Note: Addresses are limited to 32bytes in size, but may be smaller. They must always be compatible with the destination chain.","title":"Generic"},{"location":"spec/#relayer-set","text":"Each chain implementation must track a set of relayers, and allow updating of the set as necessary. A threshold should also be maintained to define how many relayers must vote for a proposed transfer before is can be executed. For this initial implementation, the relayer set may be controlled by a single party. Multi-signature wallets can be used to distribute risk, if available on the chain.","title":"Relayer Set"},{"location":"spec/#implementation","text":"This sections defines the specifics of the ChainBridge implementation and the requirements for a chain integration.","title":"Implementation"},{"location":"spec/#components","text":"","title":"Components"},{"location":"spec/#chain","text":"A chain is loosely defined as consisting of three major components: Connection : A container for on chain interactions. Shared by the listener and writer. Listener : Observes chain state transitions to watch for initiated transfers. When a transfer is encountered it should construct a message and pass it to the router. Writer : Responsible for performing on-chain actions. This will parse a proposed transfer from a message and enact it on-chain. These vary considerably depending on the chain. As long as the on-chain components are compatible, following the internal message protocol should be sufficient to be compatible with the system. These components are intended for architectural guidance and are only loosely constrained.","title":"Chain"},{"location":"spec/#message","text":"A message represents a single transfer and its associated parameters. type Message struct { Source ChainId Destination ChainId Type TransferType DepositNonce Nonce ResourceId ResourceId Payload [] interface {} } The payload field contains the data for the specific transfer, as defined above .","title":"Message"},{"location":"spec/#router","text":"The router is responsible for taking messages from a source chain and routing them to their destination chain. The router provides an interface to allow Listeners to submit constructed messages: type Router interface { Send ( message msg . Message ) error } All chains must fulfill a Writer interface to receive messages from the router: type Writer interface { ResolveMessage ( message msg . Message ) bool }","title":"Router"},{"location":"test/","text":"Testing \u00b6 Unit tests require an ethereum node running on localhost:8545 and a substrate node running on localhost:9944 . E2E tests require an additional ethereum node on localhost:8546 . A docker-compose file is provided to run two Geth nodes and a chainbridge-substrate-chain node in isolated environments: $ docker-compose -f ./docker-compose-e2e.yml up See chainbridge-solidity and chainbridge-substrate-chain for more information on testing facilities. All Go tests can be run with: $ make test Go tests specifically for ethereum, substrate and E2E can be run with $ make test-eth $ make test-sub $ make test-e2e The bindings for the solidity contracts live in bindings/ . To update the bindings modify scripts/setup-contracts.sh and then run make clean && make setup-contracts","title":"Testing"},{"location":"test/#testing","text":"Unit tests require an ethereum node running on localhost:8545 and a substrate node running on localhost:9944 . E2E tests require an additional ethereum node on localhost:8546 . A docker-compose file is provided to run two Geth nodes and a chainbridge-substrate-chain node in isolated environments: $ docker-compose -f ./docker-compose-e2e.yml up See chainbridge-solidity and chainbridge-substrate-chain for more information on testing facilities. All Go tests can be run with: $ make test Go tests specifically for ethereum, substrate and E2E can be run with $ make test-eth $ make test-sub $ make test-e2e The bindings for the solidity contracts live in bindings/ . To update the bindings modify scripts/setup-contracts.sh and then run make clean && make setup-contracts","title":"Testing"},{"location":"chains/ethereum/","text":"Ethereum Implementation Specification \u00b6 The solidity implementation of ChainBridge should consist of a central Bridge contract, and will delegate specific functionality to handlers . Fungible and non-fungible compatibility should be focused on ERC20 and ERC721 tokens. Transfer Flow \u00b6 As Source Chain \u00b6 Some user calls the deposit function on the bridge contract. A depositRecord is created on the bridge and a call is delgated to a handler contract specified by the provided resourceID . The specified handler's deposit function validates the parameters provided by the user. If successful, a depositRecord is created on the handler. If the call delegated to the handler is succesful, the bridge emits a Deposit event. Relayers parse the Deposit event and retrieve the associated DepositRecord from the handler to construct a message. As Destination Chain \u00b6 A Relayer calls voteProposal on the bridge contract. If a proposal corresponding with the parameters passed in does not exist, it is created and the Relayer's vote is recorded. If the proposal already exists, the Relayer's vote is simply recorded. Once we have met some vote threshold for a proposal , the bridge emits a ProposalFinalized event. Upon seeing a ProposalFinalized event, Relayers call the executeDeposit function on the bridge. executeDeposit delegates a call to a handler contract specified by the associated resourceID . The specified handler's executeDeposit function validates the paramters provided and makes a call to some contract to complete the transfer. Bridge Contract \u00b6 Users and relayers will interact with the Bridge contract. This delegates calls to the handler contracts for deposits and executing proposals. function deposit ( uint8 destinationChainID, bytes32 resourceID, bytes calldata data ) Handler Contracts \u00b6 To provide modularity and break out the necessary contract logic, the implementation uses a notion of handlers. A handler is defined for ERC20, ERC721 and generic transfers. These map directly to the Fungible, Non-Fungible, and generic transfer types. A handler must fulfill two interfaces: // Will be called by the bridge contract to initiate a transfer function deposit(uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) // TODO: This would be more aptly named executeProposal // Called by the bridge contract to complete a transfer function executeDeposit(bytes calldata data) The calldata field is the parameters required for the handler. The exact serialization is defined for each handler. ERC20 & ERC721 Handlers \u00b6 These handlers share a lot of similarities. These handlers are responsible for transferring ERC assets. They should provide the ability for the bridge to take ownership of tokens and release tokens to execute transfers. Different configurations may require different interface interactions. For example, it may make sense to mint and burn a token that is originally from another chain. If supply needs to be controlled, transferring tokens in and out of a reserve may be desired instead. To support either case handlers should associate each resource ID/token contract with one of these: transferFrom() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call transferFrom() as part of the transfer initiation. For the inverse, the handler will call transfer() to release tokens from the handlers ownership. mint() / burn() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call burnFrom() as part of the transfer initiation. For the inverse, the handler will call mint() to release tokens to the recipient (and must have privileges to do so). ERC20 Handler \u00b6 Calldata for deposit() \u00b6 Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END Calldata for executeDeposit() \u00b6 Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - END ERC721 Handler \u00b6 Metadata \u00b6 The tokenURI should be used as the metadata field if the contract supports the Metadata extension (interface ID 0x5b5e139f ). Calldata for deposit() \u00b6 Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END Calldata for executeDeposit() \u00b6 Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - 95 Metadata Length uint256 96 - 127 Metadata bytes 128 - END Generic Handler \u00b6 As well as associating a resource ID to a contract address, the generic handler should allow specific functions on those contracts to be used. To allow for this we must: Use function selectors to identify functions. Require functions that accept bytes as a the only parameter OR require the data already be ABI encoded for the function Deposit \u00b6 In a generic context, a deposit is simply the initiation of a transfer of a piece of data. To (optionally) allow this data to be validated for transfer the deposit mechanism should pass the data to a specified function and proceed with the transfer if the call succeeds (ie. does not revert). A function selector of 0x00 should skip the deposit function call. Execute \u00b6 An execution function must be specified. When executeDeposit() is called on the handler it should pass the metadata field to the specified function. Calldata for deposit() \u00b6 Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END Calldata for execute() \u00b6 Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END Administration \u00b6 The contracts should be controlled by an admin account. This should control the relayer set, manage the resource IDs, and specify the handlers. It should also be able to pause and unpause transfers at any times.","title":"Ethereum Implementation Specification"},{"location":"chains/ethereum/#ethereum-implementation-specification","text":"The solidity implementation of ChainBridge should consist of a central Bridge contract, and will delegate specific functionality to handlers . Fungible and non-fungible compatibility should be focused on ERC20 and ERC721 tokens.","title":"Ethereum Implementation Specification"},{"location":"chains/ethereum/#transfer-flow","text":"","title":"Transfer Flow"},{"location":"chains/ethereum/#as-source-chain","text":"Some user calls the deposit function on the bridge contract. A depositRecord is created on the bridge and a call is delgated to a handler contract specified by the provided resourceID . The specified handler's deposit function validates the parameters provided by the user. If successful, a depositRecord is created on the handler. If the call delegated to the handler is succesful, the bridge emits a Deposit event. Relayers parse the Deposit event and retrieve the associated DepositRecord from the handler to construct a message.","title":"As Source Chain"},{"location":"chains/ethereum/#as-destination-chain","text":"A Relayer calls voteProposal on the bridge contract. If a proposal corresponding with the parameters passed in does not exist, it is created and the Relayer's vote is recorded. If the proposal already exists, the Relayer's vote is simply recorded. Once we have met some vote threshold for a proposal , the bridge emits a ProposalFinalized event. Upon seeing a ProposalFinalized event, Relayers call the executeDeposit function on the bridge. executeDeposit delegates a call to a handler contract specified by the associated resourceID . The specified handler's executeDeposit function validates the paramters provided and makes a call to some contract to complete the transfer.","title":"As Destination Chain"},{"location":"chains/ethereum/#bridge-contract","text":"Users and relayers will interact with the Bridge contract. This delegates calls to the handler contracts for deposits and executing proposals. function deposit ( uint8 destinationChainID, bytes32 resourceID, bytes calldata data )","title":"Bridge Contract"},{"location":"chains/ethereum/#handler-contracts","text":"To provide modularity and break out the necessary contract logic, the implementation uses a notion of handlers. A handler is defined for ERC20, ERC721 and generic transfers. These map directly to the Fungible, Non-Fungible, and generic transfer types. A handler must fulfill two interfaces: // Will be called by the bridge contract to initiate a transfer function deposit(uint8 destinationChainID, uint64 depositNonce, address depositer, bytes calldata data) // TODO: This would be more aptly named executeProposal // Called by the bridge contract to complete a transfer function executeDeposit(bytes calldata data) The calldata field is the parameters required for the handler. The exact serialization is defined for each handler.","title":"Handler Contracts"},{"location":"chains/ethereum/#erc20-erc721-handlers","text":"These handlers share a lot of similarities. These handlers are responsible for transferring ERC assets. They should provide the ability for the bridge to take ownership of tokens and release tokens to execute transfers. Different configurations may require different interface interactions. For example, it may make sense to mint and burn a token that is originally from another chain. If supply needs to be controlled, transferring tokens in and out of a reserve may be desired instead. To support either case handlers should associate each resource ID/token contract with one of these: transferFrom() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call transferFrom() as part of the transfer initiation. For the inverse, the handler will call transfer() to release tokens from the handlers ownership. mint() / burn() - The user approves the handler to move the tokens prior to initiating the transfer. The handler will call burnFrom() as part of the transfer initiation. For the inverse, the handler will call mint() to release tokens to the recipient (and must have privileges to do so).","title":"ERC20 &amp; ERC721 Handlers"},{"location":"chains/ethereum/#erc20-handler","text":"","title":"ERC20 Handler"},{"location":"chains/ethereum/#calldata-for-deposit","text":"Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END","title":"Calldata for deposit()"},{"location":"chains/ethereum/#calldata-for-executedeposit","text":"Data Type Location Amount uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - END","title":"Calldata for executeDeposit()"},{"location":"chains/ethereum/#erc721-handler","text":"","title":"ERC721 Handler"},{"location":"chains/ethereum/#metadata","text":"The tokenURI should be used as the metadata field if the contract supports the Metadata extension (interface ID 0x5b5e139f ).","title":"Metadata"},{"location":"chains/ethereum/#calldata-for-deposit_1","text":"Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 63 - END","title":"Calldata for deposit()"},{"location":"chains/ethereum/#calldata-for-executedeposit_1","text":"Data Type Location TokenID uint256 0 - 31 Recipient Address Length uint256 32 - 63 Recipient Address bytes 64 - 95 Metadata Length uint256 96 - 127 Metadata bytes 128 - END","title":"Calldata for executeDeposit()"},{"location":"chains/ethereum/#generic-handler","text":"As well as associating a resource ID to a contract address, the generic handler should allow specific functions on those contracts to be used. To allow for this we must: Use function selectors to identify functions. Require functions that accept bytes as a the only parameter OR require the data already be ABI encoded for the function","title":"Generic Handler"},{"location":"chains/ethereum/#deposit","text":"In a generic context, a deposit is simply the initiation of a transfer of a piece of data. To (optionally) allow this data to be validated for transfer the deposit mechanism should pass the data to a specified function and proceed with the transfer if the call succeeds (ie. does not revert). A function selector of 0x00 should skip the deposit function call.","title":"Deposit"},{"location":"chains/ethereum/#execute","text":"An execution function must be specified. When executeDeposit() is called on the handler it should pass the metadata field to the specified function.","title":"Execute"},{"location":"chains/ethereum/#calldata-for-deposit_2","text":"Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END","title":"Calldata for deposit()"},{"location":"chains/ethereum/#calldata-for-execute","text":"Data Type Location Metadata Length uint256 0 - 31 Metadata bytes 32 - END","title":"Calldata for execute()"},{"location":"chains/ethereum/#administration","text":"The contracts should be controlled by an admin account. This should control the relayer set, manage the resource IDs, and specify the handlers. It should also be able to pause and unpause transfers at any times.","title":"Administration"},{"location":"chains/substrate/","text":"Substrate Implementation Specification \u00b6 The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a Proposal type equivalent to a dispatchable call to theoretically allow for any call to be made. pub trait Trait : system :: Trait { type Proposal : Parameter + Dispatchable < Origin = Self :: Origin > + EncodeLike + GetDispatchInfo ; } Events \u00b6 To easily distinguish different transfer types we should define event types for each: /// SimpleMessageTransfer is for relaying simple message (dest_id, nonce, resource_id, metadata) SimpleMessageTransfer ( ChainId , DepositNonce , ResourceId , Text ) /// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata) FungibleTransfer ( ChainId , DepositNonce , ResourceId , U256 , Vec < u8 > ) /// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata) NonFungibleTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > , Vec < u8 > , Vec < u8 > ) /// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata) GenericTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > ) These can be observed by relayers and should provide enough context to construct transfer messages. Inter-Pallet Communication \u00b6 The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers: pub fn transfer_fungible ( dest_id : ChainId , resource_id : ResourceId , to : Vec < u8 > , amount : U256 ,) pub fn transfer_nonfungible ( dest_id : ChainId , resource_id : ResourceId , token_id : Vec < u8 > , to : Vec < u8 > , metadata : Vec < u8 > ) pub fn transfer_generic ( dest_id : ChainId , resource_id : ResourceId , metadata : Vec < u8 > ) These should result in the associated event being emitted with the correct parameters. Bridge Account ID & Origin Check \u00b6 To allow the bridge pallet to take ownership of tokens a ModuleId should be used to derive an AccountId . A bridge origin check (implementing EnsureOrigin ) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal. Executing Calls \u00b6 The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin. Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls: SimpleMessage: Call(origin, from: ExtAddress, nonce: Nonce, msg: Message) Fungible: Call(origin, recipient: AccountId, amount: u128) Non-Fungible: Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec<u8>) Generic: Call(origin, data: Vec<u8>) Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls","title":"Substrate"},{"location":"chains/substrate/#substrate-implementation-specification","text":"The ChainBridge Substrate implementation will consist of a Substrate pallet that can be integrated into a runtime to enable bridging of additional pallet functionality. Due to the complexities of the Substrate API we must define some limitations to the supported calls, however the pallet should define a Proposal type equivalent to a dispatchable call to theoretically allow for any call to be made. pub trait Trait : system :: Trait { type Proposal : Parameter + Dispatchable < Origin = Self :: Origin > + EncodeLike + GetDispatchInfo ; }","title":"Substrate Implementation Specification"},{"location":"chains/substrate/#events","text":"To easily distinguish different transfer types we should define event types for each: /// SimpleMessageTransfer is for relaying simple message (dest_id, nonce, resource_id, metadata) SimpleMessageTransfer ( ChainId , DepositNonce , ResourceId , Text ) /// FungibleTransfer is for relaying fungibles (dest_id, nonce, resource_id, amount, recipient, metadata) FungibleTransfer ( ChainId , DepositNonce , ResourceId , U256 , Vec < u8 > ) /// NonFungibleTransfer is for relaying NFTS (dest_id, nonce, resource_id, token_id, recipient, metadata) NonFungibleTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > , Vec < u8 > , Vec < u8 > ) /// GenericTransfer is for a generic data payload (dest_id, nonce, resource_id, metadata) GenericTransfer ( ChainId , DepositNonce , ResourceId , Vec < u8 > ) These can be observed by relayers and should provide enough context to construct transfer messages.","title":"Events"},{"location":"chains/substrate/#inter-pallet-communication","text":"The ChainBridge pallet is intended to be combined with other pallets to define what is being bridged. To allow for this we must define some methods that other pallets can call to initiate transfers: pub fn transfer_fungible ( dest_id : ChainId , resource_id : ResourceId , to : Vec < u8 > , amount : U256 ,) pub fn transfer_nonfungible ( dest_id : ChainId , resource_id : ResourceId , token_id : Vec < u8 > , to : Vec < u8 > , metadata : Vec < u8 > ) pub fn transfer_generic ( dest_id : ChainId , resource_id : ResourceId , metadata : Vec < u8 > ) These should result in the associated event being emitted with the correct parameters.","title":"Inter-Pallet Communication"},{"location":"chains/substrate/#bridge-account-id-origin-check","text":"To allow the bridge pallet to take ownership of tokens a ModuleId should be used to derive an AccountId . A bridge origin check (implementing EnsureOrigin ) should also be provided. Other pallets should be able to use this to check the origin of call is the bridge pallet, indicating the execution of a proposal.","title":"Bridge Account ID &amp; Origin Check"},{"location":"chains/substrate/#executing-calls","text":"The pallet should support dispatching of arbitrary calls as the result of successful proposal. Resource IDs should be mapped to specific calls to define their behaviour. Relayers will need to resolve resource IDs to calls in order to submit a proposal. The pallet should provide a mapping of resource IDs to method names that can be updated by the admin. Compatible calls are restrained to the following signature to allow relayers to understand how to construct the calls: SimpleMessage: Call(origin, from: ExtAddress, nonce: Nonce, msg: Message) Fungible: Call(origin, recipient: AccountId, amount: u128) Non-Fungible: Call(origin, recipient: AccountId, tokenId: U256, metadata: Vec<u8>) Generic: Call(origin, data: Vec<u8>) Note: Calls in substrate are resolved based on a pallet and call index. The pallet index depends on the ordering of pallets in the runtime, and the call index on the ordering of calls in the pallet. As these may change during a runtime upgrade, relayers should use the actual method name string to reference calls","title":"Executing Calls"},{"location":"chains/ton/","text":"TON Implementation Specification \u00b6 Ton implementation of bridge should consist of some set of contracts: Bridge, BridgeVoteController, Proposal, Handler. As a source chain of transfer flow, ton implementation has Sender and Receiver contracts. Transfer Flow \u00b6 Some users calls sendData function of Sender contract. Sender contract calls Receiver by given address. Receiver increment nonce by given chainId and emits DataReceived event Relayers parse the DataReceived event and retrieve the associated record from the handler to construct a message. As Source Chain \u00b6 As Destination Chain \u00b6 A Relayer calls voteThrougthBridge method of Relayer contract. This method calls Bridge contract method, named relayerVoteForProposal relayerVoteForProposal method of Bridge contract calls voteByBridge method of BridgeVoteController contracts with some proposal data. If a Proposal contract corresponding with the parameters passed does not created (deployed), it is created and the Relayer's vote is recorded into. If the proposal already exists, the Relayer's vote is simply recorded. Upon passing the proposal threshold, Proposal cals executeProposal method of Handler , which in turn execute a ProposalExecuted event (outbound external message) Relayer Contract \u00b6 Relayers will interact via Relayer contract, which is essentially private relayer interaction facade. function voteThroughBridge ( uint8 choice, uint8 chainId, bytes32 messageType, uint64 nonce, bytes32 data, uint256 proposalPublicKey ) onlyOwner external Bridge Contract \u00b6 Bridge contract is a holder of bridge component addresses and also this components executor. Bridge validate, that relayer method was called by Relayer with valid code. function relayerVoteForProposal(uint8 choice, uint8 chainId, bytes32 messageType, uint64 nonce, bytes32 data, uint256 relayerPubKey, uint256 proposalPublicKey) isValidRelayer ( relayerPubKey ) external BridgeVoteController \u00b6 BridgeVoteController is a bridge component responsible for Proposal creation and execution (votes saving). Creation of proposal is a deploying a Proposal contract. function voteByBridge ( address voter, uint8 choice, uint8 chainId, bytes32 messageType, address handlerAddress, uint64 nonce, bytes32 data, uint256 proposalPublicKey ) external function createProposal(uint8 chainId, uint64 nonce, bytes32 data, uint8 initializerChoice, address initializerAddress, uint256 proposalPublicKey, address handlerAddress, bytes32 messageType) public returns ( address proposalAddress ) Proposal \u00b6 Proposal contract stores relayer votes and execute handler function voteByController ( address voter, uint8 choice, bytes32 messageType, address handlerAddress ) external Handler \u00b6 Handler is a final component of bridge. This contracts execute event with proposal results data event ProposalExecuted(uint8 chainId, uint64 nonce, bytes32 messageType, bytes32 data); Sender \u00b6 Sender is a contract for sending some data for transfering it via bridge function sendData ( IReceiver destination, bool bounce, uint128 value, bytes32 data, uint256 destinationChainId ) external onlyOwner Receiver \u00b6 Receiver is a message emitter for relayers. another task for Receiver is a chain id nonces storing function receiveData ( bytes32 data, uint256 destinationChainId ) external","title":"TON"},{"location":"chains/ton/#ton-implementation-specification","text":"Ton implementation of bridge should consist of some set of contracts: Bridge, BridgeVoteController, Proposal, Handler. As a source chain of transfer flow, ton implementation has Sender and Receiver contracts.","title":"TON Implementation Specification"},{"location":"chains/ton/#transfer-flow","text":"Some users calls sendData function of Sender contract. Sender contract calls Receiver by given address. Receiver increment nonce by given chainId and emits DataReceived event Relayers parse the DataReceived event and retrieve the associated record from the handler to construct a message.","title":"Transfer Flow"},{"location":"chains/ton/#as-source-chain","text":"","title":"As Source Chain"},{"location":"chains/ton/#as-destination-chain","text":"A Relayer calls voteThrougthBridge method of Relayer contract. This method calls Bridge contract method, named relayerVoteForProposal relayerVoteForProposal method of Bridge contract calls voteByBridge method of BridgeVoteController contracts with some proposal data. If a Proposal contract corresponding with the parameters passed does not created (deployed), it is created and the Relayer's vote is recorded into. If the proposal already exists, the Relayer's vote is simply recorded. Upon passing the proposal threshold, Proposal cals executeProposal method of Handler , which in turn execute a ProposalExecuted event (outbound external message)","title":"As Destination Chain"},{"location":"chains/ton/#relayer-contract","text":"Relayers will interact via Relayer contract, which is essentially private relayer interaction facade. function voteThroughBridge ( uint8 choice, uint8 chainId, bytes32 messageType, uint64 nonce, bytes32 data, uint256 proposalPublicKey ) onlyOwner external","title":"Relayer Contract"},{"location":"chains/ton/#bridge-contract","text":"Bridge contract is a holder of bridge component addresses and also this components executor. Bridge validate, that relayer method was called by Relayer with valid code. function relayerVoteForProposal(uint8 choice, uint8 chainId, bytes32 messageType, uint64 nonce, bytes32 data, uint256 relayerPubKey, uint256 proposalPublicKey) isValidRelayer ( relayerPubKey ) external","title":"Bridge Contract"},{"location":"chains/ton/#bridgevotecontroller","text":"BridgeVoteController is a bridge component responsible for Proposal creation and execution (votes saving). Creation of proposal is a deploying a Proposal contract. function voteByBridge ( address voter, uint8 choice, uint8 chainId, bytes32 messageType, address handlerAddress, uint64 nonce, bytes32 data, uint256 proposalPublicKey ) external function createProposal(uint8 chainId, uint64 nonce, bytes32 data, uint8 initializerChoice, address initializerAddress, uint256 proposalPublicKey, address handlerAddress, bytes32 messageType) public returns ( address proposalAddress )","title":"BridgeVoteController"},{"location":"chains/ton/#proposal","text":"Proposal contract stores relayer votes and execute handler function voteByController ( address voter, uint8 choice, bytes32 messageType, address handlerAddress ) external","title":"Proposal"},{"location":"chains/ton/#handler","text":"Handler is a final component of bridge. This contracts execute event with proposal results data event ProposalExecuted(uint8 chainId, uint64 nonce, bytes32 messageType, bytes32 data);","title":"Handler"},{"location":"chains/ton/#sender","text":"Sender is a contract for sending some data for transfering it via bridge function sendData ( IReceiver destination, bool bounce, uint128 value, bytes32 data, uint256 destinationChainId ) external onlyOwner","title":"Sender"},{"location":"chains/ton/#receiver","text":"Receiver is a message emitter for relayers. another task for Receiver is a chain id nonces storing function receiveData ( bytes32 data, uint256 destinationChainId ) external","title":"Receiver"}]}